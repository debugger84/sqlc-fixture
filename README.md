# SQLc plugin for the Dataloaders generation

This plugin is used to generate Facebook's dataloaders for each table in the database.
As a dataloader library we use [DataLoader](https://github.com/graph-gophers/dataloader) which is a Go implementation of Facebook's DataLoader.
This plugin works with the [SQLc](https://sqlc.dev/) code generator.

Dataloaders comes to us from the GraphQL world, but they can be used in any application where you need to batch and cache requests to the database.
The help to reduce the number of queries to the database and improve the performance of the application when you need to get linked data but don't or cannot use joins in your queries.

## Installation
First of all you need to install the SQLc code generator. You can find the installation instructions [here](https://sqlc.dev/docs/install).

After that you need to install the plugin. You can do it by running the following command:
```shell
git clone git@github.com:debugger84/sqlc-fixture.git
cd sqlc-fixture
make all
```

Then you need to configure your sqlc.yaml file to use the plugin. You can find the configuration instructions [here](https://sqlc.dev/docs/configuration).
For example, you can add the following lines to your sqlc.yaml file:
```yaml
version: '2'

plugins:
  - name: dataloader
    process:
      ## The path to the sqlc-fixture binary
      cmd: "../sqlc-fixture/bin/sqlc-fixture"

  - name: golang
    ## The path to the sqlc-gen-go wasm fork. 
    ## This fork improves the names of the generated structs if they are in different PostgreSQL schemas.
    ## But you can use the original sqlc-gen-go wasmas well.
    wasm:
      url: "https://github.com/debugger84/sqlc-gen-go/releases/download/v1.3.1/sqlc-gen-go.wasm"
      sha256: "fe6e5a2b75153ecba02b0c30bf4a11db2120bef537b650299473da133d272bf4"
sql:
  - schema:
    - "migration"
    - "../types/migration"
    queries: "queries"
    engine: "postgresql"

    codegen:
      - plugin: dataloader
        ## The path to the generated code. Should be the same as the path in the golang plugin.
        out: "./"
        options:
          ## The package name for the generated code. 
          ## In this case the dataloaders will be added to the subfolder "dataloaders" 
          ## instead of storing in the same folder as other generated files.
          package: "dataloader"
          ## The package name for the generated by golang plugin models.
          ## Should be set up if the "package" option is configured previously.
          model_import: "sqlc-gen-test/test"
          ## All the next options should be the same as in the "golang" plugin. 
          sql_package: "pgx/v5"
          default_schema: "test"
          overrides:
            - db_type: "uuid"
              nullable: true
              engine: "postgresql"
              go_type:
                import: "github.com/gofrs/uuid"
                package: "uuid"
                type: "NullUUID"
            - db_type: "uuid"
              nullable: false
              engine: "postgresql"
              go_type:
                import: "github.com/gofrs/uuid"
                package: "uuid"
                type: "UUID"

      - plugin: golang
        out: "./"
        options:
          package: "test"
          sql_package: "pgx/v5"
          default_schema: "test"
          exclude:
            - "User.createdAt"
            - "UpdateStatusInput.id"
          ## The same overrides as in the dataloader plugin. 
          ## If you wish to change some types, you need to do it in both plugins.
          overrides:
            - db_type: "uuid"
              nullable: true
              engine: "postgresql"
              go_type:
                import: "github.com/gofrs/uuid"
                package: "uuid"
                type: "NullUUID"
            - db_type: "uuid"
              nullable: false
              engine: "postgresql"
              go_type:
                import: "github.com/gofrs/uuid"
                package: "uuid"
                type: "UUID"
```


## Usage
After you have configured the plugin you can run the sqlc code generator as usual:
```shell
sqlc generate
```

The plugin will generate the dataloaders for each table in the database. The dataloaders will be stored in the subfolder "dataloaders" in the package you have configured in the sqlc.yaml file.

For example, if you have the following table in the database:
```sql
CREATE TABLE users (
    id uuid PRIMARY KEY,
    name TEXT NOT NULL,
    email TEXT NOT NULL
);
```

The plugin will generate the following dataloader:
```go
package dataloader

import (
	"context"
	uuid "github.com/gofrs/uuid"
	"github.com/graph-gophers/dataloader/v7"
	"github.com/jackc/pgx/v5"
	"sqlc-gen-test/test"
)

type UserLoader struct {
	innerLoader *dataloader.Loader[uuid.UUID, test.User]
	db          test.DBTX
}

func NewUserLoader(db test.DBTX) *UserLoader {
	return &UserLoader{
		db: db,
	}
}

func (l *UserLoader) getInnerLoader() *dataloader.Loader[uuid.UUID, test.User] {
	if l.innerLoader == nil {
		l.innerLoader = dataloader.NewBatchedLoader(
			func(ctx context.Context, keys []uuid.UUID) []*dataloader.Result[test.User] {
				testMap, err := l.findItemsMap(ctx, keys)

				result := make([]*dataloader.Result[test.User], len(keys))
				for i, key := range keys {
					if err != nil {
						result[i] = &dataloader.Result[test.User]{Error: err}
						continue
					}

					if loadedItem, ok := testMap[key]; ok {
						result[i] = &dataloader.Result[test.User]{Data: loadedItem}
					} else {
						result[i] = &dataloader.Result[test.User]{Error: pgx.ErrNoRows}
					}
				}
				return result
			},
		)
	}
	return l.innerLoader
}

func (l *UserLoader) findItemsMap(ctx context.Context, keys []uuid.UUID) (map[uuid.UUID]test.User, error) {
	res := make(map[uuid.UUID]test.User, len(keys))

	query := `SELECT * FROM test.test WHERE id = ANY($1)`
	rows, err := l.db.Query(ctx, query, keys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	for rows.Next() {
		var result test.User
		err := rows.Scan(
			&result.ID,
			&result.Name,
			&result.Email,
		)
		if err != nil {
			return nil, err
		}
		res[result.ID] = result
	}
	return res, nil
}

func (l *UserLoader) Load(ctx context.Context, testKey uuid.UUID) (test.User, error) {
	return l.getInnerLoader().Load(ctx, testKey)()
}

```

You can use the dataloaders in your application as follows:

```go
package main

import (
	"context"
	"fmt"
	uuid2 "github.com/google/uuid"
	"log"
	"time"

	uuid "github.com/gofrs/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
	"myproject/dataloader"
)

func main() {
	ctx := context.Background()
	db, err := pgxpool.Connect(ctx, "postgres://user:password@localhost:5432/db")
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	loader := dataloaders.NewLoader(db)
	id := uuid.Must(uuid.FromString("00000000-0000-0000-0000-000000000001"))
	result, err := loader.Load(ctx, id)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("Key: %v, Result: %v\n", id, result)
}
```

Real life example of the dataloaders usage you can find in the [examples/dataloader](https://github.com/debugger84/sqlc-graphql/tree/main/examples/dataloader) folder.